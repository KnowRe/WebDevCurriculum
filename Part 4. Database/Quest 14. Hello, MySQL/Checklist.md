### RDBMS에 길이를 알 수 없는 배열을 저장하려면 어떻게 설계해야 할까요?  
  
  *  해당 배열을 한 컬럼에 저장하는 것이 보다는 배열의 요소를 하나씩 저장 할 수 있도록 별도의 테이블을 만들어 join으로 접근하도록 하는 것이 좋을것 같다. 예를들면 아래와 같다.  
  ```sql
  create table parent (
      id varchar(50)
  )
  create table child (
      parent_id varchar(50),
      item varchar(100),
      foreign key (parent_id)
        references parent(id)
        on delete cascade
  )
  ```  

### RDBMS 테이블의 정규화는 무엇인가요?  

  * 데이터의 중복을 최소화하기 위해 데이터를 구조화 하는 작업을 정규화라고 한다. 정규화의 목적은 이상이 있는 관계를 작게 잘 조직된 관계로 재구성하는 것이다.
    1. 제1정규형: 모든 속성이 원자값으로만 구정되도록한다.
    2. 제2정규형: 제1정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 완전함수종속이 되도록한다.
    3. 제3정규형: 제2정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 이행적 함수종속이 되지 않도록 한다.

### MySQL 엔진에는 어떤 것들이 있나요?

  1. InnoDB: row-level 잠금, FK 제약 등을 지원하며, MVCC, 버퍼 풀, Undo로그, Redo 로그 등으로 데이터의 효과적인 커밋과 롤백을 수행한다. 현재 MySql의 default 엔진이다.

  2. MyISAM: table-level 잠금을 지원하기 때문에 멀티쓰레드 환경에서 속도가 느리다. InnoDB의 버퍼 풀과 비슷한 역할을 하는 키캐시를 사용한다.

  3. MEMORY: HEAP 엔진이라고도 하며, 데이터를 메모리에 저장하는 것이 특징이다. 하지만 MyISAM과 같이 table-level 잠금을 지원하기 때문에 멀티쓰레드 환경에서 속도가 느리다.

  4. ARCHIVE: 데이터가 메모리상에서 압축되고 압축된 상태로 디스크에 저장되는 것이 특징이다. row-level 잠금을 지원하며, 한번 insert된 데이터는 update, delete 될 수 없으며, 인덱스를 지원하지 않는다.

  5. 이외에도 CSV, BLACKHOLE, MERGE, FEDERATED 엔진 등이 있다.

### RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?

  1. 인덱스는 지정한 컬럼의 데이터를 기준으로 정렬하여 메모리 영역에 목차를 생성하는것이다. 따라서 해당 인덱스 키로 보다 빠르게 데이터 row에 접근하는 것이 가능하다. 
  
  2. 인덱싱을 하게 되면, 테이블을 풀 스캔 하지 않아도 찾고자 하는 데이터를 바로 찾아하는 것이 가능하기 때문에 데이터의 읽기 속도를 높일 수 있다. 하지만 데이터의 저장, 삭제의 경우 인덱스 페이지의 재정렬이 필요하므로 성능이 떨어진다. 

  3. 인덱싱 알고리즘에서 일반적으로 사용되는 B-Tree인덱스를 기준으로, 인덱스 검색은 루트 -> 브랜치 -> 리프 페이지 순으로 인덱스 페이지를 검색하여 대상 인덱스를 찾는다. 루트, 브랜치, 리프는 트리구조로 구성되어 있다.


### DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?

  * 사용자의 암호를 해쉬함수를 통해 암호화하기 때문이다. 오늘날의 대부분의 사용자 암호는 평문을 데이터베이스에 저장될 경우, 피해가 막심하기 때문에 암호화를 거친다. 가장 잘 알려진 SHA-256해쉬 함수와 Salt값, 그리고 해쉬함수의 반복 횟수등을 조합하여 사용자 암호를 변환한 값을 데이터베이스에 저장하면, 해킹으로 비밀번호가 유출되었다 하더라도 사용자 암호를 밝혀내는 것은 어렵다.

